# Oracle数据库

## 概述

### 基本术语

#### 数据字典

​	数据字典是Oracle数据库的重要组成部分。它由一系列拥有数据库元数据（metadata）信息的数据字典表和用户可以读取的数据字典视图组成,存放有Oracle数据库所用的有关信息。主要信息主要有：

- 系统的空间信息，即分配了多少空间，当前使用了多少空间等。
- 数据库中所有模式的对象，如表、试图、簇、索引及同义词等。
- 例程运行的性能和统计信息。
- Oracle用户的名字。
- 用户访问或使用审计的信息。
- 用户及角色被授予的权限信息。
- 列的约束信息的完整性。
- 列的缺省值。

![数据字典](../图片/Oracle/数据字典.png)

#### 数据文件

​	一个Oracle数据库可以拥有一个或多个**物理**的数据文件。**在数据文件中包含了数据库中的全部数据。**逻辑数据库结构的数据也物理的存储在数据文件中。数据文件有一下特征：

- **一个数据库可以对应多个数据文件；**
-  **可以设置数据文件使其在数据库空间用完的情况下自动自行扩展。**
- **一个表空间（数据库存储的逻辑单位）可以由一个或多个数据文件组成。**

**表空间是一个或多个数据文件在逻辑上的统一组织，而数据文件是对表空间的物理支撑。**我们在操作数据库的时候，常常按表为单位来划分，而这个表就是一个表空间，它是一个逻辑的概念，意思是这个表中的数据在磁盘上不一定是存放在一起的，可以分别分布在好多的数据文件上。**所以说，数据文件是数据库的物理支撑，表空间是数据库的逻辑支撑。**

#### 控制文件

​	数据库控制文件是一个很小的二进制文件，它维护着数据库的全局物理结构，用以支撑数据库成功的启动和运行。**通常来说，控制文件一直是可写的状态，当由于某些原因导致控制文件不能访问时，此时数据库也就不能正常运行了。**

#### 日志文件

​	日志问价也被称为重做日志文件。重做日志文件用于记录对数据库的所有修改信息，可以用来备份和回复数据库。

![文件说明](../图片/Oracle/文件说明.png)

#### 表空间

​	表空间是Oracle数据库中最大的逻辑结构。它是组织数据和进行空间分配的逻辑结构，可以将表空间看做是数据库对象的容器。**表空间就是一个或多个数据文件（物理文件）的集合（逻辑上的文件），所有的数据对象都被逻辑地存放在指定的表空间中。**

​	一个数据库通常包括SYSTEM、SYSAUX、TEMP三个默认的空间，一个或多个临时表空间，还有一个撤销表空间和几个应用程序专用的空间。可以创建新的表空间，需要指定类型：

##### 表空间的类型

1. **系统表空间（System  tablespace）：**系统表空间包括SYSTEM和SYSAUX表空间，系统表空间是所有数据库必须且自动创建的，一般存放Oracle数据字典表及相应的数据。
2. **永久表空间（Permanent  tablespace）：永久表空间用于保存永久数据，如系统数据、应用系统数据等，每个用户都会被分配一个永久表空间。**
3. **临时表空间（Temporary  tablespace）：**这些空间主要用于查询带有分组、排序等子句时才会用到，用完即释放。
4. **撤销表空间：**在Oracle9i版本之后采用，提供了自动撤销管理（SMU），以前的撤销方式是通过回滚段（segment）的方式来撤销的，称为手工撤销管理（RBU），在Oracle11g数据库中默认采用自动撤销表空间管理。**在一个数据库中只能选择两种撤销方式之一。**
5. 大文件表空间和小文件表空间

##### 表空间的状态

​	有三种：读写状态（默认状态）、只读状态（只支持select语句，用来保护静态数据）、脱机状态（出于脱机状态的表空间不可以被用户访问到）。

#### 段（segment）

​	**段用于存储表空间中某一种特定的具有独立存储结构的对象的所有数据，它由一个或多个区组成。**

​	**段是数据区的集合，每个段分配特定的数据结构，存储在相同的表空间中。**

​	**段的数据区在磁盘上可能不是连续的，段可以跨多个数据文件。**	

​	段分为：数据段、索引段、临时段、回滚段等几种类型。

##### 数据段

​	数据段用来存储表中的数据。**每建立一个表，就会在该表的默认表空间中建立一个数据段，与表名相同。**

##### 索引段

​	索引段用于存储所有的索引数据。**当采用CREATE  INDEX创建索引或者采用约束的方式创建索引（如主键索引）时，就在默认表空间中同名的索引段。**

##### 临时段

​	临时段用来存储排序操作所产生的临时数据。排序结束。自动清除。

##### 回滚段

​	回滚段用于存储用户数据被修改之前的值。回滚段用来提供为事务读一致性的保证。

#### 区

​	区（EXtent）是由物理上连续存放的快构成。**区是Oracle存储分配的最小单位。**

#### 数据块

​	数据块（Block）是最小的数据管理单位，也是执行输入输出操作时的最小单位。相应地，操作系统执行输入输出操作的最小单位是操作系统块。Oracle系统块的大小是操作系统的整数倍，最小2K，最大64K。

​	**数据块就是用来存放数据的逻辑单位。以一定的结构以二进制的方式存放在数据文件中。**

![数据库的逻辑存储结构](../图片/Oracle/数据库的逻辑存储结构.png)

### Oracle中的数据类型

![oracle中的数据类型](../图片/Oracle/oracle中的数据类型.png)

**注意，在字符串中，Oracle一般是采用varchar2类型的。**

## Oracle数据库的语法

### 数据定义

![数据定义](../图片/Oracle/数据定义.png)

oracle数据库中的数据定义语句常用这三种，分别对应表、视图和索引。

**表：**与MySQL数据库中的表没啥不一样的地方。

**视图：**是从基表或其他视图中导出的表，是虚表。本身不存在与数据库。

#### CREATE语句

##### 创建表

​	下图是创建表的格式：

![创建表的格式](../图片/Oracle/创建表的格式.png)

与MySQL中创建表的语句是一样的。

##### 创建视图

​	视图是从一个或多个基表（或视图）中导出的表，它与基表不同，是一个虚表。**数据库中只是存放视图的定义而不存放视图中的数据，这些数据任然放在原来的基表中。所以基表中的数据发生变化，在视图中的数据也将发生变化。**

其语法格式为：

![创建视图](../图片/Oracle/创建视图.png)

其中，子查询是可以不包含ORDER  BY子句和DISTINCT子句的任意SELECT子句。WITH  CHECK  OPTION表示对视图进行UPDATE 、INSERT、DELETE等语句时，要保证更新、插入或删除的行要满足视图定义中的谓词条件（即子查询中的条件表达式）。

![创建视图示例](../图片/Oracle/创建视图示例.png)

如上图，是一个创建视图的示例，卡伊看到加上了WITH  CHECK  OPTION,这代表在以后对该视图进行更新、插入等操作时，会在这些语句的后面加上条件JOB_ID = IT_PROG这个条件。

##### 创建索引

![创建索引](../图片/Oracle/创建索引.png)

**聚簇索引将和表记录存放在一起，所以一个基表只能有一个聚簇索引。聚簇索引一般用在查询频率很高，但是更新频率很低的列上。**

#### DROP语句

​	DROP语句用来删除。

##### 删除表

![删除表](../图片/Oracle/删除表.png)

##### 删除视图

​	删除视图的语句为：

```SQL
DROP VIEW 视图名
```

视图删除仅是将该视图的定义从数据字典中删除，不会影响其中的数据。同时，由该视图导出的其它视图是不会被删除的，只是在访问时可能会发生错误。

##### 删除索引

```SQL
DROP INDEX 索引名；
```

#### ALTER语句

​	ALTER TABLE语句用来修改基表的定义。

![修改表结构](../图片/Oracle/修改表结构.png)

表名：指定要修改的表；

ADD：用于增加新列和数据类型,约束条件是可选的.

DROP：用于删除指定列的约束条件

MODIFY:用于修改某一列的列名和数据类型.

Oracle中并没有提供删除列的语法,想要删除列只能是将该表中的数据复制到新表中,删除该表,重命名另一个表。

### 数据查询

SELECT语句的完整语法是：

![SELECT语句](../图片/Oracle/SELECT语句.png)

在oracle数据库中，其查询的语法如上，大部分使用的还是标准的SQL语法，不再赘述。

### 多表联结查询

#### 简单联结

![简单连接](../图片/Oracle/简单连接.png)

简单连接就是在SELECT子句和FROM子句中通过使用逗号分隔多个列和表，其查询的结果是一个笛卡尔积的表。查询结果的行数是两个基表行数的积。

#### 条件限定

​	笛卡尔积通常是会产生大量的重复数据，所以一般不会采用那种方式，我们可以添加限定条件来减少重复数据的输出。例如：

![条件限定](../图片/Oracle/条件限定.png)

例如上图，同样是两个表，但是加上WHERE条件后，查询的数据就是我们想要在两个表中关联的数据了。

#### 表别名

​	**注意，表别名用在from子句之后。而且在指定了表别名之后，那么所有的子句中只能使用表的别名而不能使用原先的名字了。**其它的与MySQL一样。

![表别名](../图片/Oracle/表别名.png)

#### JOIN连接查询

![JOIN语法](../图片/Oracle/JOIN语法.png)

上图是使用JOIN语句的格式，其中join_type代表的是采用内联结还是外联结等，下面具体说明其怎么用。

##### 内联结

​	**内联结的关键字是INNER JOIN。**注意的是，整个连接语句写在from子句中，除了要指明连接的类型之外，还要用ON关键字来指明**两个表之间连接**的条件。

​	其用法与MySQL一样。

##### 自然连接

​	自然连接使用NATURE  JOIN关键字，而不需要ON关键字。

![自然连接](../图片/Oracle/自然连接.png)

![自然连接的说明](../图片/Oracle/自然连接的说明.png)

**自然连接一般来说没用。**

##### 外联结

​	**要注意的是，内联结仅仅是扩展行数；而外联结是对列的扩展；一般来说，内联结查询的是在两个表中都有的记录；而外联结的话查询的时候就有一个主表了，以主表为主进行查询。**

![外联结](../图片/Oracle/外联结.png)

左外和右外联结的语法同MySQL一样，不再赘述。

![完全外联结](../图片/Oracle/完全外联结.png)

##### 自连接

​	所谓自连接，就是将本表的一个列作为了本表的一个外键。查询时，实际查找的是一张表，但要将它看成两张表来看，例如：

![自连接](../图片/Oracle/自连接.png)

![自连接说明](../图片/Oracle/自连接说明.png)

### 集合操作

​	在Oracle中的集合操作有：UNION(并运算)、UNION ALL（全并运算）、INTERSECT（交运算）、MINUS（差运算）。

#### UNION运算

![UNION运算](../图片/Oracle/UNION运算.png)

#### UNION ALL运算

​	UNION ALL运算区别于UNION运算的地方就是它不会对两个查询结果进行去重运算。

#### INTERSECT运算

![INTERSCET运算](../图片/Oracle/INTERSCET运算.png)

#### MINUS运算

![MINUS运算](../图片/Oracle/MINUS运算.png)

#### 使用集合运算注意的点

- 在构成复合运算的各个查询语句上，个SELECT语句中指定的列必须在数量上和数据类型上相匹配。
- 不允许在个SELECT语句中使用ORDER BY子句。
- 不允许在BLOB、LONG这样的大数据类型上使用复合运算。

### 子查询

![子查询](../图片/Oracle/子查询.png)

#### 使用IN关键字

![IN关键字示例](../图片/Oracle/IN关键字示例.png)

#### EXISTS关键字

![EXISTS关键字](../图片/Oracle/EXISTS关键字.png)

![EXISTS示例](../图片/Oracle/EXISTS示例.png)

在该语句中，外层查询的每一行结果，都会根据子查询来判断，只有子查询的结果为true时，外查询才会返回。

#### 比较运算符

![比较运算符](../图片/Oracle/比较运算符.png)

![比较运算符示例](../图片/Oracle/比较运算符示例.png)

**注意，在使用比较运算符操作子查询时，必须保证子查询的返回值是一个唯一的、确定的值。否则将会失败。**

### 分页查询

​	**在MySQL中分页采用的是limit关键字，其语法为limit（m，n），m为起始行，n为查询的行数；而在Oracle中，是不能采用limit关键字的，其分页要采用rownum来完成。**

​	在oracle中，rownum的意思是一个行号，其实代表的是一列数据，Oracle中的每个表上都有这一列数据。但是它是一个伪劣，并不会在表中显示的表示出这一列数据。它存在的意义就是为该表中的每一行记录用一个行号来标识。所以，要显示一个表中的前5列可以采用如下的形式：

![rownum](../图片/Oracle/rownum.png)

**但是，要注意的是，在一个实际表中，rownum只能采用小于号表示，而不能采用大于号的语法。所以，在显示一个表的中间数据时就有问题，不能每次显示都从第一行到当前行。**

​	所以，为了可以分页，我们可以采用一种迂回的方式，其思想是：**既然在一个实际表上rownum是只能采用小于号而不能采用大于号的话，那么我们可以想办法产生一张假想的表，该表上的包含原表中的所有数据和rownum列，而此时的rownum列应该成为这张假想表的一个实际列。那么该怎么完成呢？采用子查询的方式，用子查询创造一张临时表，该表包含原表的所有数据和rownum列，而此时，在rownum列上就可以用where条件限定起始行和查询的行数了。**其语句为：

![rownum分页](../图片/Oracle/rownum分页.png)

### 数据操纵

​	常用的数据操纵语句有INSERT、DELETE、UPDATE和TRUNCATE语句。前三个与MySQL不无不同，不再赘述。

#### 序列

​	在很多数据库中都存在一个自动增长的列，比如在MySQL中在插入操作时就可以用AUTO INCREMENT指定某一个列是自动增长的，而在oracle数据库中就没有这么方便了，**在oracle中需要使用序列来完成这一过程。而且它是需要手工维护这个自动增长的列的。**

```SQL
CREATE SEQUENCE 序列名
[INCREMENT BY n]
[START WITH n]
[{MAXVALUE/ MINVALUE n|NOMAXVALUE}]
[{CYCLE|NOCYCLE}]
[{CACHE n|NOCACHE}];
```

例如，创建一个 seqpersonid的序列,验证自动增长的操作：

```SQL
CREATE SEQUENCE seqpersonid;
```

序列创建完成之后,所有的自动增长应该由用户自己处理,所以在序列中提供了以下的两种操作：

- **nextval :**取得序列的下一个内容
- **currval :**取得序列的当前内容

```SQL
select seqpersonid.nextval from dual;
select seqpersonid.currval from dual;
```

在插入数据时需要自增的主键中可以这样使用：

```SQL
-- 在这条语句中seqpersonId.nextval的值作为主键，其表结构如下图
INSERT INTO person
values(seqpersonId.nextval,'宋江','1',null,'北京');
```

![序列](../图片/Oracle/序列.png)

如上图所示，表中的pid是该表的主键，为了保证唯一，使用序列来填充该主键的值。**从这里也可以看出，序列是单独存在的，与哪张表是没有关系的，意思是该序列可以用在这张表也可以用在其它表上。但是，需要注意的是，序列的值也与表无关联，加入两张表共用一个序列，那么这张表从序列中获取一个值后，另一张表只会获取到该序列的下一个值，所以在实际中，一般都是一张表创建一个序列的。**

#### TRUNCATE语句

​	TRUNCATE语句删除表中所有的记录。TRUANCATE语句要快与DELETE语句，因为不能产生回滚信息，所以它的删除不能撤销。

![truncate语句](../图片/Oracle/truncate语句.png)

## Oracle数据库的常用函数

### 字符类函数

#### ASCII（c1）

![ASCII函数](../图片/Oracle/ASCII函数.png)

![ASCII示例](../图片/Oracle/ASCII示例.png)

![ASCII结果](../图片/Oracle/ASCII结果.png)

#### CHR（i）

![CHR函数](../图片/Oracle/CHR函数.png)

![CHR示例](../图片/Oracle/CHR示例.png)

其结果与上表相似，只是输出的结果是字符。

#### CONCAT（c1，c2）

![CONCAT函数](../图片/Oracle/CONCAT函数.png)

![CONCAT示例](../图片/Oracle/CONCAT示例.png)

#### INITCAP（c1）

![INITCAP函数](../图片/Oracle/INITCAP函数.png)

![INITCAP示例](../图片/Oracle/INITCAP示例.png)

![INSTR函数](../图片/Oracle/INSTR函数.png)

![LENGTH函数](../图片/Oracle/LENGTH函数.png)

![LOWER函数](../图片/Oracle/LOWER函数.png)

![LTRIM函数](../图片/Oracle/LTRIM函数.png)

![REPLACE函数](../图片/Oracle/REPLACE函数.png)

### 数字类函数

![数字类函数](../图片/Oracle/数字类函数.png)

### 日期类函数

![日期类函数](../图片/Oracle/日期类函数.png)

**注意，Oracle中日期类的函数操作的绝大多数都是DATA类型的。**

## Oracle  PL/SQL语言及编程

### 简介

#### 基本结构

​	PL/SQL的基本的结构如下：

![PLSQL基本结构](../图片/Oracle/PLSQL基本结构.png)

从上图可以看出，它包含了三个部分：声明部分、执行部分和异常处理部分。**该结构到最后的分号是必须的。**

​	如果没有声明部分就以BEGIN开头，如果没有异常处理部分，EXCEPTION可以被省略；而END关键字和后面的分号是必不可少的。那么这样的话，其可以有如下两种形式：

![简化的plsql结构](../图片/Oracle/简化的plsql结构.png)

#### PL/SQL的数据类型

​	PL/SQL的数据类型也可以看做数据库的数据类型：

##### 数值类型

### 	数字类型的变量存储整数或者实数。它包含NUMBER、PLS_INTEGER和BINARY_INTEGER三种基本类型。其中NUMBER类型的变量可以存储整数或者实数类型的变量，而其它两种只能存储整数。